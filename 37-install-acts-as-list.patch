install-acts-as-list

From: Bryan Larsen <bryan@larsen.st>

# Task re-ordering

We're now going to add the ability to re-order a story's tasks by
drag-and-drop. There's support for this built into Hobo, so there's
not much to do. First we need the `acts_as_list` plugin.  Run

    $ rails plugin install git://github.com/swanandp/acts_as_list.git
---
 vendor/plugins/acts_as_list/README                 |   23 +
 vendor/plugins/acts_as_list/Rakefile               |   12 
 vendor/plugins/acts_as_list/init.rb                |    3 
 .../acts_as_list/lib/active_record/acts/list.rb    |  265 ++++++++++
 vendor/plugins/acts_as_list/test/list_test.rb      |  550 ++++++++++++++++++++
 5 files changed, 853 insertions(+), 0 deletions(-)
 create mode 100644 vendor/plugins/acts_as_list/README
 create mode 100644 vendor/plugins/acts_as_list/Rakefile
 create mode 100644 vendor/plugins/acts_as_list/init.rb
 create mode 100644 vendor/plugins/acts_as_list/lib/active_record/acts/list.rb
 create mode 100644 vendor/plugins/acts_as_list/test/list_test.rb

diff --git a/vendor/plugins/acts_as_list/README b/vendor/plugins/acts_as_list/README
new file mode 100644
index 0000000..36ae318
--- /dev/null
+++ b/vendor/plugins/acts_as_list/README
@@ -0,0 +1,23 @@
+ActsAsList
+==========
+
+This acts_as extension provides the capabilities for sorting and reordering a number of objects in a list. The class that has this specified needs to have a +position+ column defined as an integer on the mapped database table.
+
+
+Example
+=======
+
+  class TodoList < ActiveRecord::Base
+    has_many :todo_items, :order => "position"
+  end
+
+  class TodoItem < ActiveRecord::Base
+    belongs_to :todo_list
+    acts_as_list :scope => :todo_list
+  end
+
+  todo_list.first.move_to_bottom
+  todo_list.last.move_higher
+
+
+Copyright (c) 2007 David Heinemeier Hansson, released under the MIT license
\ No newline at end of file
diff --git a/vendor/plugins/acts_as_list/Rakefile b/vendor/plugins/acts_as_list/Rakefile
new file mode 100644
index 0000000..e6c6369
--- /dev/null
+++ b/vendor/plugins/acts_as_list/Rakefile
@@ -0,0 +1,12 @@
+require 'rake'
+require 'rake/testtask'
+
+desc 'Default: run acts_as_list unit tests.'
+task :default => :test
+
+desc 'Test the acts_as_ordered_tree plugin.'
+Rake::TestTask.new(:test) do |t|
+  t.libs << 'lib'
+  t.pattern = 'test/**/*_test.rb'
+  t.verbose = true
+end
diff --git a/vendor/plugins/acts_as_list/init.rb b/vendor/plugins/acts_as_list/init.rb
new file mode 100644
index 0000000..eb87e87
--- /dev/null
+++ b/vendor/plugins/acts_as_list/init.rb
@@ -0,0 +1,3 @@
+$:.unshift "#{File.dirname(__FILE__)}/lib"
+require 'active_record/acts/list'
+ActiveRecord::Base.class_eval { include ActiveRecord::Acts::List }
diff --git a/vendor/plugins/acts_as_list/lib/active_record/acts/list.rb b/vendor/plugins/acts_as_list/lib/active_record/acts/list.rb
new file mode 100644
index 0000000..ff12e6b
--- /dev/null
+++ b/vendor/plugins/acts_as_list/lib/active_record/acts/list.rb
@@ -0,0 +1,265 @@
+module ActiveRecord
+  module Acts #:nodoc:
+    module List #:nodoc:
+      def self.included(base)
+        base.extend(ClassMethods)
+      end
+
+      # This +acts_as+ extension provides the capabilities for sorting and reordering a number of objects in a list.
+      # The class that has this specified needs to have a +position+ column defined as an integer on
+      # the mapped database table.
+      #
+      # Todo list example:
+      #
+      #   class TodoList < ActiveRecord::Base
+      #     has_many :todo_items, :order => "position"
+      #   end
+      #
+      #   class TodoItem < ActiveRecord::Base
+      #     belongs_to :todo_list
+      #     acts_as_list :scope => :todo_list
+      #   end
+      #
+      #   todo_list.first.move_to_bottom
+      #   todo_list.last.move_higher
+      module ClassMethods
+        # Configuration options are:
+        #
+        # * +column+ - specifies the column name to use for keeping the position integer (default: +position+)
+        # * +scope+ - restricts what is to be considered a list. Given a symbol, it'll attach <tt>_id</tt> 
+        #   (if it hasn't already been added) and use that as the foreign key restriction. It's also possible 
+        #   to give it an entire string that is interpolated if you need a tighter scope than just a foreign key.
+        #   Example: <tt>acts_as_list :scope => 'todo_list_id = #{todo_list_id} AND completed = 0'</tt>
+        def acts_as_list(options = {})
+          configuration = { :column => "position", :scope => "1 = 1" }
+          configuration.update(options) if options.is_a?(Hash)
+
+          configuration[:scope] = "#{configuration[:scope]}_id".intern if configuration[:scope].is_a?(Symbol) && configuration[:scope].to_s !~ /_id$/
+
+          if configuration[:scope].is_a?(Symbol)
+            scope_condition_method = %(
+              def scope_condition
+                self.class.send(:sanitize_sql_hash_for_conditions, { :#{configuration[:scope].to_s} => send(:#{configuration[:scope].to_s}) })
+              end
+            )
+          elsif configuration[:scope].is_a?(Array)
+            scope_condition_method = %(
+              def scope_condition
+                attrs = %w(#{configuration[:scope].join(" ")}).inject({}) do |memo,column| 
+                  memo[column.intern] = send(column.intern); memo
+                end
+                self.class.send(:sanitize_sql_hash_for_conditions, attrs)
+              end
+            )
+          else
+            scope_condition_method = "def scope_condition() \"#{configuration[:scope]}\" end"
+          end
+
+          class_eval <<-EOV
+            include ActiveRecord::Acts::List::InstanceMethods
+
+            def acts_as_list_class
+              ::#{self.name}
+            end
+
+            def position_column
+              '#{configuration[:column]}'
+            end
+
+            #{scope_condition_method}
+
+            before_destroy :decrement_positions_on_lower_items
+            before_create  :add_to_list_bottom
+          EOV
+        end
+      end
+
+      # All the methods available to a record that has had <tt>acts_as_list</tt> specified. Each method works
+      # by assuming the object to be the item in the list, so <tt>chapter.move_lower</tt> would move that chapter
+      # lower in the list of all chapters. Likewise, <tt>chapter.first?</tt> would return +true+ if that chapter is
+      # the first in the list of all chapters.
+      module InstanceMethods
+        # Insert the item at the given position (defaults to the top position of 1).
+        def insert_at(position = 1)
+          insert_at_position(position)
+        end
+
+        # Swap positions with the next lower item, if one exists.
+        def move_lower
+          return unless lower_item
+
+          acts_as_list_class.transaction do
+            lower_item.decrement_position
+            increment_position
+          end
+        end
+
+        # Swap positions with the next higher item, if one exists.
+        def move_higher
+          return unless higher_item
+
+          acts_as_list_class.transaction do
+            higher_item.increment_position
+            decrement_position
+          end
+        end
+
+        # Move to the bottom of the list. If the item is already in the list, the items below it have their
+        # position adjusted accordingly.
+        def move_to_bottom
+          return unless in_list?
+          acts_as_list_class.transaction do
+            decrement_positions_on_lower_items
+            assume_bottom_position
+          end
+        end
+
+        # Move to the top of the list. If the item is already in the list, the items above it have their
+        # position adjusted accordingly.
+        def move_to_top
+          return unless in_list?
+          acts_as_list_class.transaction do
+            increment_positions_on_higher_items
+            assume_top_position
+          end
+        end
+
+        # Removes the item from the list.
+        def remove_from_list
+          if in_list?
+            decrement_positions_on_lower_items
+            update_attribute position_column, nil
+          end
+        end
+
+        # Increase the position of this item without adjusting the rest of the list.
+        def increment_position
+          return unless in_list?
+          update_attribute position_column, self.send(position_column).to_i + 1
+        end
+
+        # Decrease the position of this item without adjusting the rest of the list.
+        def decrement_position
+          return unless in_list?
+          update_attribute position_column, self.send(position_column).to_i - 1
+        end
+
+        # Return +true+ if this object is the first in the list.
+        def first?
+          return false unless in_list?
+          self.send(position_column) == 1
+        end
+
+        # Return +true+ if this object is the last in the list.
+        def last?
+          return false unless in_list?
+          self.send(position_column) == bottom_position_in_list
+        end
+
+        # Return the next higher item in the list.
+        def higher_item
+          return nil unless in_list?
+          acts_as_list_class.find(:first, :conditions =>
+            "#{scope_condition} AND #{position_column} = #{(send(position_column).to_i - 1).to_s}"
+          )
+        end
+
+        # Return the next lower item in the list.
+        def lower_item
+          return nil unless in_list?
+          acts_as_list_class.find(:first, :conditions =>
+            "#{scope_condition} AND #{position_column} = #{(send(position_column).to_i + 1).to_s}"
+          )
+        end
+
+        # Test if this record is in a list
+        def in_list?
+          !send(position_column).nil?
+        end
+
+        private
+          def add_to_list_top
+            increment_positions_on_all_items
+          end
+
+          def add_to_list_bottom
+            if self[position_column].nil?
+              self[position_column] = bottom_position_in_list.to_i + 1 
+            else
+              increment_positions_on_lower_items(self[position_column])
+            end
+          end
+
+          # Overwrite this method to define the scope of the list changes
+          def scope_condition() "1" end
+
+          # Returns the bottom position number in the list.
+          #   bottom_position_in_list    # => 2
+          def bottom_position_in_list(except = nil)
+            item = bottom_item(except)
+            item ? item.send(position_column) : 0
+          end
+
+          # Returns the bottom item
+          def bottom_item(except = nil)
+            conditions = scope_condition
+            conditions = "#{conditions} AND #{self.class.primary_key} != #{except.id}" if except
+            acts_as_list_class.find(:first, :conditions => conditions, :order => "#{position_column} DESC")
+          end
+
+          # Forces item to assume the bottom position in the list.
+          def assume_bottom_position
+            update_attribute(position_column, bottom_position_in_list(self).to_i + 1)
+          end
+
+          # Forces item to assume the top position in the list.
+          def assume_top_position
+            update_attribute(position_column, 1)
+          end
+
+          # This has the effect of moving all the higher items up one.
+          def decrement_positions_on_higher_items(position)
+            acts_as_list_class.update_all(
+              "#{position_column} = (#{position_column} - 1)", "#{scope_condition} AND #{position_column} <= #{position}"
+            )
+          end
+
+          # This has the effect of moving all the lower items up one.
+          def decrement_positions_on_lower_items
+            return unless in_list?
+            acts_as_list_class.update_all(
+              "#{position_column} = (#{position_column} - 1)", "#{scope_condition} AND #{position_column} > #{send(position_column).to_i}"
+            )
+          end
+
+          # This has the effect of moving all the higher items down one.
+          def increment_positions_on_higher_items
+            return unless in_list?
+            acts_as_list_class.update_all(
+              "#{position_column} = (#{position_column} + 1)", "#{scope_condition} AND #{position_column} < #{send(position_column).to_i}"
+            )
+          end
+
+          # This has the effect of moving all the lower items down one.
+          def increment_positions_on_lower_items(position)
+            acts_as_list_class.update_all(
+              "#{position_column} = (#{position_column} + 1)", "#{scope_condition} AND #{position_column} >= #{position}"
+           )
+          end
+
+          # Increments position (<tt>position_column</tt>) of all items in the list.
+          def increment_positions_on_all_items
+            acts_as_list_class.update_all(
+              "#{position_column} = (#{position_column} + 1)",  "#{scope_condition}"
+            )
+          end
+
+          def insert_at_position(position)
+            remove_from_list
+            increment_positions_on_lower_items(position)
+            self.update_attribute(position_column, position)
+          end
+      end 
+    end
+  end
+end
diff --git a/vendor/plugins/acts_as_list/test/list_test.rb b/vendor/plugins/acts_as_list/test/list_test.rb
new file mode 100644
index 0000000..895dee9
--- /dev/null
+++ b/vendor/plugins/acts_as_list/test/list_test.rb
@@ -0,0 +1,550 @@
+require 'test/unit'
+
+require 'rubygems'
+gem 'activerecord', '>= 1.15.4.7794'
+require 'active_record'
+
+require "#{File.dirname(__FILE__)}/../init"
+
+ActiveRecord::Base.establish_connection(:adapter => "sqlite3", :database => ":memory:")
+
+def setup_db
+  ActiveRecord::Schema.define(:version => 1) do
+    create_table :mixins do |t|
+      t.column :pos, :integer
+      t.column :parent_id, :integer
+      t.column :parent_type, :string
+      t.column :created_at, :datetime      
+      t.column :updated_at, :datetime
+    end
+  end
+end
+
+def teardown_db
+  ActiveRecord::Base.connection.tables.each do |table|
+    ActiveRecord::Base.connection.drop_table(table)
+  end
+end
+
+class Mixin < ActiveRecord::Base
+end
+
+class ListMixin < Mixin
+  acts_as_list :column => "pos", :scope => :parent
+
+  def self.table_name() "mixins" end
+end
+
+class ListMixinSub1 < ListMixin
+end
+
+class ListMixinSub2 < ListMixin
+end
+
+class ListWithStringScopeMixin < ActiveRecord::Base
+  acts_as_list :column => "pos", :scope => 'parent_id = #{parent_id}'
+
+  def self.table_name() "mixins" end
+end
+
+class ArrayScopeListMixin < Mixin
+  acts_as_list :column => "pos", :scope => [:parent_id, :parent_type]
+
+  def self.table_name() "mixins" end
+end
+
+class ListTest < Test::Unit::TestCase
+
+  def setup
+    setup_db
+    (1..4).each { |counter| ListMixin.create! :pos => counter, :parent_id => 5 }
+  end
+
+  def teardown
+    teardown_db
+  end
+
+  def test_reordering
+    assert_equal [1, 2, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+
+    ListMixin.find(2).move_lower
+    assert_equal [1, 3, 2, 4], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+
+    ListMixin.find(2).move_higher
+    assert_equal [1, 2, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+
+    ListMixin.find(1).move_to_bottom
+    assert_equal [2, 3, 4, 1], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+
+    ListMixin.find(1).move_to_top
+    assert_equal [1, 2, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+
+    ListMixin.find(2).move_to_bottom
+    assert_equal [1, 3, 4, 2], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+
+    ListMixin.find(4).move_to_top
+    assert_equal [4, 1, 3, 2], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+  end
+
+  def test_move_to_bottom_with_next_to_last_item
+    assert_equal [1, 2, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+    ListMixin.find(3).move_to_bottom
+    assert_equal [1, 2, 4, 3], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+  end
+
+  def test_next_prev
+    assert_equal ListMixin.find(2), ListMixin.find(1).lower_item
+    assert_nil ListMixin.find(1).higher_item
+    assert_equal ListMixin.find(3), ListMixin.find(4).higher_item
+    assert_nil ListMixin.find(4).lower_item
+  end
+
+  def test_injection
+    item = ListMixin.new(:parent_id => 1)
+    assert_equal '"mixins"."parent_id" = 1', item.scope_condition
+    assert_equal "pos", item.position_column
+  end
+
+  def test_insert
+    new = ListMixin.create(:parent_id => 20)
+    assert_equal 1, new.pos
+    assert new.first?
+    assert new.last?
+
+    new = ListMixin.create(:parent_id => 20)
+    assert_equal 2, new.pos
+    assert !new.first?
+    assert new.last?
+
+    new = ListMixin.create(:parent_id => 20)
+    assert_equal 3, new.pos
+    assert !new.first?
+    assert new.last?
+
+    new = ListMixin.create(:parent_id => 0)
+    assert_equal 1, new.pos
+    assert new.first?
+    assert new.last?
+  end
+
+  def test_insert_at
+    new = ListMixin.create(:parent_id => 20)
+    assert_equal 1, new.pos
+
+    new = ListMixin.create(:parent_id => 20)
+    assert_equal 2, new.pos
+
+    new = ListMixin.create(:parent_id => 20)
+    assert_equal 3, new.pos
+
+    new4 = ListMixin.create(:parent_id => 20)
+    assert_equal 4, new4.pos
+
+    new4.insert_at(3)
+    assert_equal 3, new4.pos
+
+    new.reload
+    assert_equal 4, new.pos
+
+    new.insert_at(2)
+    assert_equal 2, new.pos
+
+    new4.reload
+    assert_equal 4, new4.pos
+
+    new5 = ListMixin.create(:parent_id => 20)
+    assert_equal 5, new5.pos
+
+    new5.insert_at(1)
+    assert_equal 1, new5.pos
+
+    new4.reload
+    assert_equal 5, new4.pos
+  end
+
+  def test_delete_middle
+    assert_equal [1, 2, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+
+    ListMixin.find(2).destroy
+
+    assert_equal [1, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+
+    assert_equal 1, ListMixin.find(1).pos
+    assert_equal 2, ListMixin.find(3).pos
+    assert_equal 3, ListMixin.find(4).pos
+
+    ListMixin.find(1).destroy
+
+    assert_equal [3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+
+    assert_equal 1, ListMixin.find(3).pos
+    assert_equal 2, ListMixin.find(4).pos
+  end
+
+  def test_with_string_based_scope
+    new = ListWithStringScopeMixin.create(:parent_id => 500)
+    assert_equal 1, new.pos
+    assert new.first?
+    assert new.last?
+  end
+
+  def test_nil_scope
+    new1, new2, new3 = ListMixin.create, ListMixin.create, ListMixin.create
+    new2.move_higher
+    assert_equal [new2, new1, new3], ListMixin.find(:all, :conditions => 'parent_id IS NULL', :order => 'pos')
+  end
+
+  def test_remove_from_list_should_then_fail_in_list? 
+    assert_equal true, ListMixin.find(1).in_list?
+    ListMixin.find(1).remove_from_list
+    assert_equal false, ListMixin.find(1).in_list?
+  end 
+  
+  def test_remove_from_list_should_set_position_to_nil 
+    assert_equal [1, 2, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+  
+    ListMixin.find(2).remove_from_list 
+  
+    assert_equal [2, 1, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+  
+    assert_equal 1,   ListMixin.find(1).pos
+    assert_equal nil, ListMixin.find(2).pos
+    assert_equal 2,   ListMixin.find(3).pos
+    assert_equal 3,   ListMixin.find(4).pos
+  end 
+  
+  def test_remove_before_destroy_does_not_shift_lower_items_twice 
+    assert_equal [1, 2, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+  
+    ListMixin.find(2).remove_from_list 
+    ListMixin.find(2).destroy 
+  
+    assert_equal [1, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+  
+    assert_equal 1, ListMixin.find(1).pos
+    assert_equal 2, ListMixin.find(3).pos
+    assert_equal 3, ListMixin.find(4).pos
+  end 
+  
+  def test_before_destroy_callbacks_do_not_update_position_to_nil_before_deleting_the_record
+    assert_equal [1, 2, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+
+    # We need to trigger all the before_destroy callbacks without actually
+    # destroying the record so we can see the affect the callbacks have on
+    # the record.
+    list = ListMixin.find(2)
+    if list.respond_to?(:run_callbacks)
+      list.run_callbacks(:before_destroy)
+    else
+      list.send(:callback, :before_destroy)
+    end
+
+    assert_equal [1, 2, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+
+    assert_equal 1, ListMixin.find(1).pos
+    assert_equal 2, ListMixin.find(2).pos
+    assert_equal 2, ListMixin.find(3).pos
+    assert_equal 3, ListMixin.find(4).pos
+  end
+  
+  def test_before_create_callback_adds_to_bottom
+    assert_equal [1, 2, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+
+    new = ListMixin.create(:parent_id => 5)
+    assert_equal 5, new.pos
+    assert !new.first?
+    assert new.last?
+  
+    assert_equal [1, 2, 3, 4, 5], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+  end 
+
+  def test_before_create_callback_adds_to_given_position
+    assert_equal [1, 2, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+
+    new = ListMixin.create(:pos => 1, :parent_id => 5)
+    assert_equal 1, new.pos
+    assert new.first?
+    assert !new.last?
+  
+    assert_equal [5, 1, 2, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+
+    new = ListMixin.create(:pos => 3, :parent_id => 5)
+    assert_equal 3, new.pos
+    assert !new.first?
+    assert !new.last?
+
+    assert_equal [5, 1, 6, 2, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5', :order => 'pos').map(&:id)
+  end 
+
+end
+
+class ListSubTest < Test::Unit::TestCase
+
+  def setup
+    setup_db
+    (1..4).each { |i| ((i % 2 == 1) ? ListMixinSub1 : ListMixinSub2).create! :pos => i, :parent_id => 5000 }
+  end
+
+  def teardown
+    teardown_db
+  end
+
+  def test_reordering
+    assert_equal [1, 2, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5000', :order => 'pos').map(&:id)
+
+    ListMixin.find(2).move_lower
+    assert_equal [1, 3, 2, 4], ListMixin.find(:all, :conditions => 'parent_id = 5000', :order => 'pos').map(&:id)
+
+    ListMixin.find(2).move_higher
+    assert_equal [1, 2, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5000', :order => 'pos').map(&:id)
+
+    ListMixin.find(1).move_to_bottom
+    assert_equal [2, 3, 4, 1], ListMixin.find(:all, :conditions => 'parent_id = 5000', :order => 'pos').map(&:id)
+
+    ListMixin.find(1).move_to_top
+    assert_equal [1, 2, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5000', :order => 'pos').map(&:id)
+
+    ListMixin.find(2).move_to_bottom
+    assert_equal [1, 3, 4, 2], ListMixin.find(:all, :conditions => 'parent_id = 5000', :order => 'pos').map(&:id)
+
+    ListMixin.find(4).move_to_top
+    assert_equal [4, 1, 3, 2], ListMixin.find(:all, :conditions => 'parent_id = 5000', :order => 'pos').map(&:id)
+  end
+
+  def test_move_to_bottom_with_next_to_last_item
+    assert_equal [1, 2, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5000', :order => 'pos').map(&:id)
+    ListMixin.find(3).move_to_bottom
+    assert_equal [1, 2, 4, 3], ListMixin.find(:all, :conditions => 'parent_id = 5000', :order => 'pos').map(&:id)
+  end
+
+  def test_next_prev
+    assert_equal ListMixin.find(2), ListMixin.find(1).lower_item
+    assert_nil ListMixin.find(1).higher_item
+    assert_equal ListMixin.find(3), ListMixin.find(4).higher_item
+    assert_nil ListMixin.find(4).lower_item
+  end
+
+  def test_injection
+    item = ListMixin.new("parent_id"=>1)
+    assert_equal '"mixins"."parent_id" = 1', item.scope_condition
+    assert_equal "pos", item.position_column
+  end
+
+  def test_insert_at
+    new = ListMixin.create("parent_id" => 20)
+    assert_equal 1, new.pos
+
+    new = ListMixinSub1.create("parent_id" => 20)
+    assert_equal 2, new.pos
+
+    new = ListMixinSub2.create("parent_id" => 20)
+    assert_equal 3, new.pos
+
+    new4 = ListMixin.create("parent_id" => 20)
+    assert_equal 4, new4.pos
+
+    new4.insert_at(3)
+    assert_equal 3, new4.pos
+
+    new.reload
+    assert_equal 4, new.pos
+
+    new.insert_at(2)
+    assert_equal 2, new.pos
+
+    new4.reload
+    assert_equal 4, new4.pos
+
+    new5 = ListMixinSub1.create("parent_id" => 20)
+    assert_equal 5, new5.pos
+
+    new5.insert_at(1)
+    assert_equal 1, new5.pos
+
+    new4.reload
+    assert_equal 5, new4.pos
+  end
+
+  def test_delete_middle
+    assert_equal [1, 2, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5000', :order => 'pos').map(&:id)
+
+    ListMixin.find(2).destroy
+
+    assert_equal [1, 3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5000', :order => 'pos').map(&:id)
+
+    assert_equal 1, ListMixin.find(1).pos
+    assert_equal 2, ListMixin.find(3).pos
+    assert_equal 3, ListMixin.find(4).pos
+
+    ListMixin.find(1).destroy
+
+    assert_equal [3, 4], ListMixin.find(:all, :conditions => 'parent_id = 5000', :order => 'pos').map(&:id)
+
+    assert_equal 1, ListMixin.find(3).pos
+    assert_equal 2, ListMixin.find(4).pos
+  end
+
+end
+
+class ArrayScopeListTest < Test::Unit::TestCase
+
+  def setup
+    setup_db
+    (1..4).each { |counter| ArrayScopeListMixin.create! :pos => counter, :parent_id => 5, :parent_type => 'ParentClass' }
+  end
+
+  def teardown
+    teardown_db
+  end
+
+  def test_reordering
+    assert_equal [1, 2, 3, 4], ArrayScopeListMixin.find(:all, :conditions => "parent_id = 5 AND parent_type = 'ParentClass'", :order => 'pos').map(&:id)
+
+    ArrayScopeListMixin.find(2).move_lower
+    assert_equal [1, 3, 2, 4], ArrayScopeListMixin.find(:all, :conditions => "parent_id = 5 AND parent_type = 'ParentClass'", :order => 'pos').map(&:id)
+
+    ArrayScopeListMixin.find(2).move_higher
+    assert_equal [1, 2, 3, 4], ArrayScopeListMixin.find(:all, :conditions => "parent_id = 5 AND parent_type = 'ParentClass'", :order => 'pos').map(&:id)
+
+    ArrayScopeListMixin.find(1).move_to_bottom
+    assert_equal [2, 3, 4, 1], ArrayScopeListMixin.find(:all, :conditions => "parent_id = 5 AND parent_type = 'ParentClass'", :order => 'pos').map(&:id)
+
+    ArrayScopeListMixin.find(1).move_to_top
+    assert_equal [1, 2, 3, 4], ArrayScopeListMixin.find(:all, :conditions => "parent_id = 5 AND parent_type = 'ParentClass'", :order => 'pos').map(&:id)
+
+    ArrayScopeListMixin.find(2).move_to_bottom
+    assert_equal [1, 3, 4, 2], ArrayScopeListMixin.find(:all, :conditions => "parent_id = 5 AND parent_type = 'ParentClass'", :order => 'pos').map(&:id)
+
+    ArrayScopeListMixin.find(4).move_to_top
+    assert_equal [4, 1, 3, 2], ArrayScopeListMixin.find(:all, :conditions => "parent_id = 5 AND parent_type = 'ParentClass'", :order => 'pos').map(&:id)
+  end
+
+  def test_move_to_bottom_with_next_to_last_item
+    assert_equal [1, 2, 3, 4], ArrayScopeListMixin.find(:all, :conditions => "parent_id = 5 AND parent_type = 'ParentClass'", :order => 'pos').map(&:id)
+    ArrayScopeListMixin.find(3).move_to_bottom
+    assert_equal [1, 2, 4, 3], ArrayScopeListMixin.find(:all, :conditions => "parent_id = 5 AND parent_type = 'ParentClass'", :order => 'pos').map(&:id)
+  end
+
+  def test_next_prev
+    assert_equal ArrayScopeListMixin.find(2), ArrayScopeListMixin.find(1).lower_item
+    assert_nil ArrayScopeListMixin.find(1).higher_item
+    assert_equal ArrayScopeListMixin.find(3), ArrayScopeListMixin.find(4).higher_item
+    assert_nil ArrayScopeListMixin.find(4).lower_item
+  end
+
+  def test_injection
+    item = ArrayScopeListMixin.new(:parent_id => 1, :parent_type => 'ParentClass')
+    assert_equal '"mixins"."parent_id" = 1 AND "mixins"."parent_type" = \'ParentClass\'', item.scope_condition
+    assert_equal "pos", item.position_column
+  end
+
+  def test_insert
+    new = ArrayScopeListMixin.create(:parent_id => 20, :parent_type => 'ParentClass')
+    assert_equal 1, new.pos
+    assert new.first?
+    assert new.last?
+
+    new = ArrayScopeListMixin.create(:parent_id => 20, :parent_type => 'ParentClass')
+    assert_equal 2, new.pos
+    assert !new.first?
+    assert new.last?
+
+    new = ArrayScopeListMixin.create(:parent_id => 20, :parent_type => 'ParentClass')
+    assert_equal 3, new.pos
+    assert !new.first?
+    assert new.last?
+
+    new = ArrayScopeListMixin.create(:parent_id => 0, :parent_type => 'ParentClass')
+    assert_equal 1, new.pos
+    assert new.first?
+    assert new.last?
+  end
+
+  def test_insert_at
+    new = ArrayScopeListMixin.create(:parent_id => 20, :parent_type => 'ParentClass')
+    assert_equal 1, new.pos
+
+    new = ArrayScopeListMixin.create(:parent_id => 20, :parent_type => 'ParentClass')
+    assert_equal 2, new.pos
+
+    new = ArrayScopeListMixin.create(:parent_id => 20, :parent_type => 'ParentClass')
+    assert_equal 3, new.pos
+
+    new4 = ArrayScopeListMixin.create(:parent_id => 20, :parent_type => 'ParentClass')
+    assert_equal 4, new4.pos
+
+    new4.insert_at(3)
+    assert_equal 3, new4.pos
+
+    new.reload
+    assert_equal 4, new.pos
+
+    new.insert_at(2)
+    assert_equal 2, new.pos
+
+    new4.reload
+    assert_equal 4, new4.pos
+
+    new5 = ArrayScopeListMixin.create(:parent_id => 20, :parent_type => 'ParentClass')
+    assert_equal 5, new5.pos
+
+    new5.insert_at(1)
+    assert_equal 1, new5.pos
+
+    new4.reload
+    assert_equal 5, new4.pos
+  end
+
+  def test_delete_middle
+    assert_equal [1, 2, 3, 4], ArrayScopeListMixin.find(:all, :conditions => "parent_id = 5 AND parent_type = 'ParentClass'", :order => 'pos').map(&:id)
+
+    ArrayScopeListMixin.find(2).destroy
+
+    assert_equal [1, 3, 4], ArrayScopeListMixin.find(:all, :conditions => "parent_id = 5 AND parent_type = 'ParentClass'", :order => 'pos').map(&:id)
+
+    assert_equal 1, ArrayScopeListMixin.find(1).pos
+    assert_equal 2, ArrayScopeListMixin.find(3).pos
+    assert_equal 3, ArrayScopeListMixin.find(4).pos
+
+    ArrayScopeListMixin.find(1).destroy
+
+    assert_equal [3, 4], ArrayScopeListMixin.find(:all, :conditions => "parent_id = 5 AND parent_type = 'ParentClass'", :order => 'pos').map(&:id)
+
+    assert_equal 1, ArrayScopeListMixin.find(3).pos
+    assert_equal 2, ArrayScopeListMixin.find(4).pos
+  end
+  
+  def test_remove_from_list_should_then_fail_in_list? 
+    assert_equal true, ArrayScopeListMixin.find(1).in_list?
+    ArrayScopeListMixin.find(1).remove_from_list
+    assert_equal false, ArrayScopeListMixin.find(1).in_list?
+  end 
+  
+  def test_remove_from_list_should_set_position_to_nil 
+    assert_equal [1, 2, 3, 4], ArrayScopeListMixin.find(:all, :conditions => "parent_id = 5 AND parent_type = 'ParentClass'", :order => 'pos').map(&:id)
+  
+    ArrayScopeListMixin.find(2).remove_from_list 
+  
+    assert_equal [2, 1, 3, 4], ArrayScopeListMixin.find(:all, :conditions => "parent_id = 5 AND parent_type = 'ParentClass'", :order => 'pos').map(&:id)
+  
+    assert_equal 1,   ArrayScopeListMixin.find(1).pos
+    assert_equal nil, ArrayScopeListMixin.find(2).pos
+    assert_equal 2,   ArrayScopeListMixin.find(3).pos
+    assert_equal 3,   ArrayScopeListMixin.find(4).pos
+  end 
+  
+  def test_remove_before_destroy_does_not_shift_lower_items_twice 
+    assert_equal [1, 2, 3, 4], ArrayScopeListMixin.find(:all, :conditions => "parent_id = 5 AND parent_type = 'ParentClass'", :order => 'pos').map(&:id)
+  
+    ArrayScopeListMixin.find(2).remove_from_list 
+    ArrayScopeListMixin.find(2).destroy 
+  
+    assert_equal [1, 3, 4], ArrayScopeListMixin.find(:all, :conditions => "parent_id = 5 AND parent_type = 'ParentClass'", :order => 'pos').map(&:id)
+  
+    assert_equal 1, ArrayScopeListMixin.find(1).pos
+    assert_equal 2, ArrayScopeListMixin.find(3).pos
+    assert_equal 3, ArrayScopeListMixin.find(4).pos
+  end 
+  
+end
+
